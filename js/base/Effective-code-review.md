[TOC]

## 高效的代码审查
在团队中进行代码审查(Code Review)可以提升代码质量，分享项目知识。而且在reivew过程中，能让你的代码可以更好的组织起来，最终达到构建更好的软件、更好的团队。如果你花几分钟搜索代码审查的相关信息，你会看到许多关于代码审查带来的价值的文章。目前有很多方法来进行代码审查：在github中提pull request，或使用像JetBrains的Upsource之类的工具。然而即使用拥有清晰的流程和正确的工具，还遗留了一个大问题需要解决——我们需要找寻哪些问题。

### 要点
* 代码审查者在审查代码时有非常多的东西需要关注。一个团队需要明确对于自己的项目哪些点是重要的，并不断在审查中就这些点进行检查。
* 人工审查代码是十分昂贵的，因此尽可能地使用自动化方式进行审查，如：代码格式，代码样式，检查常见bug，确定常见安全问题以及运行自动化测试。
* 当针对性能进行审查时，了解系统的性能需求是明确潜在问题的关键。
* 一些简单的人工检查可以显著提升应用的安全性。
* 代码审查是应该在互相沟通中进行讨论的，而不是相互对抗。预先确定哪些是要点哪些不是，可以减少冲突并拟定预期。

-----
### 设计
* 如何让新代码与全局的架构保持一致？
* 代码是否遵循SOLID原则，是否遵循团队使用的设计规范，如领域驱动开发等？
* 新代码是否有使用设计模式？这样使用是否合适？
* 基础代码是否有结合使用了一些标准或设计样式，新的代码是否遵循当前的规范？代码是否正确迁移，或参照了因不规范而淘汰的旧代码？
* 代码的位置是否正确？比如涉及订单的新代码是否在订单服务相关的位置？
* 新代码是否重用了现存的代码？新代码是否可以被现有代码重用？新代码是否有重用代码？如果是，那是否要重构，还是当前可以接受？
* 新代码是否被过度设计了？是否现在还不需要的重用设计？团队如何平衡可重用和YAGNI(You Ain't Gonna Need It)这两种观点？

-----
### 可读性和可维护性
* 字段、变量、参数、方法、类的命名是否真实反映它们所代表的事物。
* 函数是否过长？
* 我是否可以通过代码阅读来理解它做了什么？
* 我是否理解测试用例测了什么？
* 测试是否很好地覆盖了用例的各种情况？它们是否覆盖了正常和异常用例？是否有忽略的情况？
* 错误信息是否可被理解？
* 不清晰的代码是否被文档、注释或容易理解的测试用例所覆盖？具体可以根据团队自身的喜好决定使用哪种方式。
* 第三方库的引入是否有API文档？

-----
### 功能
* 代码是否真的达到了预期的目标？如果有自动化测试来确保代码的正确性，测试的代码是否真的可以验证代码达到了协定的需求？
* 代码看上去是否包含不明显的bug，比如使用错误的变量进行检查，或误把and写成or？

-----
### 你是否考虑过？
* 是否需要满足相关监管需求？
* 作者是否需要创建公共文档或修改现存的帮助文档？
* 是否检查了面向用户的信息的正确性？
* 是否有会在生产环境中导致应用停止运行的明显错误？代码是否会错误地指向测试数据库，是否存在应在真实服务中移除的硬编码的stub代码？
* 你对性能的需求是什么，你是否考虑了安全问题？这些是需要覆盖到的重大区域也是至关重要的话题。

-----
### 测试
* 新的或修改的代码有测试吗？
* 测试有覆盖到代码中令人困惑或者复杂的部分吗？
* 我能理解这些测试吗？
* 这些测试需要满足什么要求？
* 我可以考虑没有被现有测试覆盖到的用例吗？
* 这些测试是否有说明代码的限制条件？
* 审查代码中的测试类型、测试级别正确吗？
* 有没有针对安全性的测试？
* 有没有针对性能的测试？

-----
### 性能
让我们深入探讨下性能，这是一个真正能从代码审查中获益的方面。

系统对性能方面的非功能性需求应当同所有架构、设计的领域一样被置于重要的位置。无论你是开发只容许纳秒级延时的低延迟交易系统，还是管理"待办事项"的手机应用，你都应该了解用户所认为的"太慢"。

在考虑我们是否需要就代码性能进行代码审查之前，我们应该问自己几个关于具体需求是什么的问题。虽然一些应用确实不需要考虑每毫秒都花费在哪里，对于大部分应用，花费几个小时的折腾进行优化来获得的些许CPU下降的价值也是有限的，但有些地方还是审查者可以检查一下的，进而确保代码不会有一些常见可避免的性能缺陷。

#### 这段代码是否有硬性的性能需求？
接受审查的代码是否涉及之前发布的服务等级协议(SLA)？或这个需求本身有特别的性能需求？

如果代码导致"登录页加载太慢"，那原始的开发者需要找出合适的加载时间是多久，不然审查者或作者本人如何确保改进后的速度足够快？

如果有硬性的需求，是否有测试能证明满足了该需求？任何注重性能的系统应该就性能提供自动化测试，这能确保发布的SLA达到预期。没有这些，你只能依靠你的用户来告诉你没有达到对应的SLA。这不仅是一种糟糕的用户体验，还会带来原本可避免的罚金和支出。

#### 这个修复或新增的功能是否会反向影响到任何现存的性能测试结果？
#### 调用外部的服务或应用的代价是昂贵的
任何通过网络来使用外部系统的方式通常会比没有很好优化的方法有更差的性能。

#### 有效且高效地使用资源
* 代码是否用锁来控制共享资源的访问？这是否会导致性能降低或死锁？
* 是否存在内存泄漏？
* 是否存在内存无限增长？这个和内存泄漏不同，内存泄漏是指无用的对象不能被GC回收。但对于任何语言，就算没有GC的语言，也能创建无限变大的数据结构。作为审查者，如果你看见新的变量不断被加到list或map中，你就要问下，这个list或map什么时候失效或清除无用数据。
* 代码是否关闭了连接或数据流？
* 资源池是否配置正确？

#### 正确性
* 是否使用了正确的数据结构？
* 代码容易出现竞态条件？多线程环境中代码非常容易造成不明显的竞态条件。作为审查者，可以查看不是原子操作的get和set。
* 代码是否正确使用锁？
* 缓存：虽然缓存是一种能防止过多高消耗请求的方式，但其本身也存在一些挑战，如不正确的缓存失效方式。

#### 代码级优化
* 代码是否在不需要的地方使用同步或锁操作？如果代码始终运行在单线程中，锁往往是不必要的。
* 代码是否可以使用原子变量替代锁或同步操作？
* 代码是否使用了不必要的线程安全的数据结构？比如是否可以使用ArrayList替代Vector？
* 代码是否在通用的操作中使用了低性能的数据结构？如在经常需要查找某个特定元素的地方使用链表。
* 代码是否可以使用懒加载并从中获得性能提升？
* 条件判断语句或其他逻辑是否可以将最高效的求值语句放在前面来使其他语句短路？
* 代码是否存在许多字符串格式化？是否有方法可以使它更高效？
* 日志语句是否使用了字符串格式化？是否先使用条件判断语句校验了日志等级，或使用延迟求值？

#### 高性能代码的表现
* 编写小的方法和类
* 保持逻辑简单——不要使用深入嵌套的 if 或循环。

-----
### 安全
你在构建一个安全、稳固的系统所花费的精力，和花在其他特性上的一样，取决于项目本身，项目运行的地方、它使用的用户、需要访问的数据等。我们现在着重看一些你可能在代码审查时关注的地方。

#### 尽可能使用自动化安全检测
#### 理解你用到的依赖
第三方类库是侵蚀系统安全并引起漏洞的一个途径。当审查代码时至少你要检查是否引入了新的依赖。你也应该尝试着最小化每个类库的版本，当然如果其他依赖有一个额外的间接依赖，这点可能达不到。但最简单的最小化自己代码暴露在他人代码的安全问题中的方法有：
* 尽可能使用源码并理解它的可信度。
* 使用你所能得到的质量最高的类库。
* 追踪你在何处使用了什么，当新的漏洞出现，你可以查看你受影响的程度。

#### 检查是否新的路径和服务需要认证
#### 数据是否需要加密
#### 密码是否被很好地控制？
这里的密码包含密码(如用户密码、数据库密码或其他系统的密码)、密匙、令牌等。这些永远不应该存放在会提交到源码控制系统的代码或配置文件中，有其他方式管理这些密码，例如通过密码服务器(secret server)。当审查代码时，要确保这些密码不会悄悄进入你的版本控制系统。

#### 代码的运行是否应该被日志记录或监控？是否正确地使用？
日志和监控需求因各个项目而不同，一些需要合规，一些拥有比别人严格的行为、事件日志规范。如果你有规章规定哪些需要记录日志，何时、如何记录，那么作为代码审查者你应该检查提交的代码是否满足要求。如果你没有固定的规章，那么就考虑：
* 代码是否改变了数据(如增删改操作)？是否应该记录由谁何时改变了什么？
* 代码是否涉及关键性能的部分？是否应该在性能监控系统中记录开始时间和结束时间？
* 每条日志的日志等级是否恰当？一个好的经验法则是"ERROR"触发一个提示发送到某处，如果你不想这些消息在凌晨3点叫醒谁，那么就将之降级为"INFO"或"DEBUG"。当在循环中或一条数据可能产生多条输出的情况下，一般不需要将它们记录到生产日志文件中，它们更应该被放在"DEBUG"级别。

-----
### S.O.L.I.D原则
SOLID原则 是面向对象程序设计和编程的五个核心原则。我们可以根据这些原则去指出代码中的异味，从而修正。

#### 单一职责原则(SRP)
当需要作出修改时，原因只能有一个。这有助于帮助开发者理解所构建事物的上下文和职责，并理解何时需要修改。

#### 开放封闭原则(OCP)
行为的改变应该可以在不改变现有代码的条件下进行，例如，使用拓展点和创建可以插入的代码。

#### 里氏替换原则(LSP)
派生的对象或类型必须能够替换其基类。

#### 接口分离原则(ISP)
不应该强迫客户端实现一个它用不上的接口，或是说客户端不应该被迫依赖它们不使用的方法。

#### 依赖倒置原则(DIP)
考虑两个概念，抽象(Abstraction)和所有权(Ownership)。前者指的是我们应该依赖抽象，而不是依赖具体实现；后者指的是底层实现应该依赖高层概念。

-----
### 总结
代码审查是一个很好的方式，不仅确保了代码质量和一致性，也在团队中或团队间分享了项目知识。即使你已经自动化了基础的校验，还有许多不同代码、设计的方面需要考虑。代码审查工具，如Upsource，通过在每个代码提交的检查中高亮可疑的代码并分析哪些问题已经被修复，新引入哪些问题，可以帮你定位一些潜在的问题。工具也可以简化流程，因为它提供了一个平台来讨论设计和代码实现，也可以邀请审查者、作者和其他相关人员参加讨论直到达成共识。

最后，团队需要花时间决定代码质量的哪些因素对他们是重要的，也需要专家人工决定哪些规则应用到各个代码审查中，参与到审查中的每个人都应该具备并使用人际交往的技巧，如积极的反馈、谈判妥协以达到最终的共识，即代码应该怎么样才“足够好”可以通过审查。