[TOC]

## 命令模式

### 介绍
将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，经这样处理过的方法调用可以在任何需要的时候执行。它也可以用来消除调用操作的对象和实现操作的对象之间的耦合，这为各种具体的类的更换带来了极大的灵活性。

### 基本实现
最简形式的命令对象是一个操作和用以调用这个操作的对象的结合体。所有的命令对象都有一个执行操作，其用途就是调用命令对象所绑定的操作(action)。

假设有一个广告公司，设计好一个网页后，客户可以在上面执行一些与自己账户相关的操作，比如启用和停用某些广告。因为不知道其中具体的广告梳理，所以要设计一个尽可能灵活的用户界面。

首先要做的是定义一个所有命令对象都必须实现的接口：
```
var AdCommand = new Interface('AdCommand', ['execute']);
```
接下来定义两个类，分别用来封装广告的start方法和stop方法：
```
var StopAd = function(adObject) {
  this.ad = adObject
};
StopAd.prototype.execute = function() {
  this.ad.stop();
};

var StartAd = function(adObject) {
  this.ad = adObject
};
StartAd.prototype.execute = function() {
  this.ad.start();
};
```
这是两个非常典型的命令类。它们的构造函数以另一个对象为参数，而它们实现的 `execute()` 方法则要调用该对象的某个方法。现在有了两个可用在用户界面的类，它们具有相同的接口。你不知道也不关心adObject的具体实现细节，只要它实现了start和stop方法就行。

UiButton类的构造函数有两个参数，一个是按钮上的文字，另一个是命令对象。当按钮被点击时会执行那个命令对象的execute方法。
```
var ads = getAds();
for (var i = 0, len = ads.length; i < len; i += 1) {
  var startCommand = new StartAd(ads[i]);
  var stopCommand = new StopAd(ads[i]);
  
  new UiButton('start' + ads[i].name, startCommand);
  new UiButton('stop' + ads[i].name, stopCommand);
}
```

上面我们可以看到命令模式的精髓所在：把命令的调用者 `UiButton` 与执行者 `AdCommand` 分开，使双方不必关心对方是如何操作的。

###  总结
#### 优点
首先，命令模式的封装性很好：每个命令都被封装起来，对于客户端来说，需要什么功能就去调用相应的命令，而无需知道命令具体是怎么执行的。比如有一组文件操作的命令：新建文件、复制文件、删除文件。如果把这三个操作都封装成一个命令类，客户端只需要知道有这三个命令类即可，至于命令类中封装好的逻辑，客户端则无需知道。

其次，命令模式的扩展性很好，在命令模式中，在接收者类中一般会对操作进行最基本的封装，命令类则通过对这些基本的操作进行二次封装，当增加新命令的时候，对命令类的编写一般不是从零开始的，有大量的接收者类可供调用，也有大量的命令类可供调用，代码的复用性很好。比如，文件的操作中，我们需要增加一个剪切文件的命令，则只需要把复制文件和删除文件这两个命令组合一下就行了，非常方便。

#### 缺点
命令如果很多，开发起来就要头疼了。特别是很多简单的命令，实现起来就几行代码的事，而使用命令模式的话，不用管命令多简单，都需要写一个命令类来封装，这样容易造成一种浪费，也会给代码调试增加难度。
